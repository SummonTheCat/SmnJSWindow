/**
 * Exports the current CSS variables as a style.css file.
 */
function exportStyle() {
    const exportButton = document.getElementById('export-style-button');
    if (!exportButton) {
        console.warn('Export Style button not found.');
        return;
    }

    // Define groups and their variables
    const variableGroups = [
        {
            title: 'Text Position Variables - Initial Phase',
            variables: [
                '--fallback-heading-top',
                '--fallback-description-top',
                '--fallback-button-accept-top'
            ]
        },
        {
            title: 'Text Width Variables - Initial Phase',
            variables: [
                '--fallback-heading-width',
                '--fallback-description-width'
            ]
        },
        {
            title: 'Text Font Size Variables - Initial Phase',
            variables: [
                '--fallback-heading-font-size',
                '--fallback-description-font-size'
            ]
        },
        {
            title: 'Text Position Variables - Post-Accept Phase',
            variables: [
                '--post-accept-fallback-heading-top',
                '--post-accept-fallback-description-top',
                '--post-accept-fallback-prize-top',
                '--post-accept-fallback-button-play-now-top',
                '--post-accept-fallback-button-play-later-top',
                '--post-accept-fallback-button-continue-top'
            ]
        },
        {
            title: 'Text Width Variables - Post-Accept Phase',
            variables: [
                '--post-accept-fallback-heading-width',
                '--post-accept-fallback-description-width',
                '--post-accept-fallback-prize-width'
            ]
        },
        {
            title: 'Text Font Size Variables - Post-Accept Phase',
            variables: [
                '--post-accept-fallback-heading-font-size',
                '--post-accept-fallback-description-font-size',
                '--post-accept-fallback-prize-font-size'
            ]
        },
        {
            title: 'PRE-ACCEPT PHASE STYLES',
            variables: [
                '--fallback-heading-color',
                '--fallback-heading-text-shadow',
                '--fallback-heading-font-weight',
                '--fallback-description-color',
                '--fallback-description-text-shadow',
                '--fallback-description-font-weight'
            ]
        },
        {
            title: 'POST-ACCEPT PHASE STYLES',
            variables: [
                '--post-accept-fallback-heading-color',
                '--post-accept-fallback-heading-text-shadow',
                '--post-accept-fallback-heading-font-weight',
                '--post-accept-fallback-description-color',
                '--post-accept-fallback-description-text-shadow',
                '--post-accept-fallback-description-font-weight',
                '--post-accept-fallback-prize-color',
                '--post-accept-fallback-prize-text-shadow',
                '--post-accept-fallback-prize-font-weight'
            ]
        },
        {
            title: 'BUTTON STYLING VARIABLES',
            variables: [
                // Accept Button
                '--accept-button-bg',
                '--accept-button-bg-hover', // Added
                '--accept-button-fg',
                '--accept-button-border-color',
                '--accept-button-border-width',
                '--accept-button-text-shadow',
                '--accept-button-font-weight',
                '--accept-button-border-radius',
                '--accept-button-font-size',
                // Play Now Button
                '--play-now-button-bg',
                '--play-now-button-bg-hover', // Added
                '--play-now-button-fg',
                '--play-now-button-border-color',
                '--play-now-button-border-width',
                '--play-now-button-text-shadow',
                '--play-now-button-font-weight',
                '--play-now-button-border-radius',
                '--play-now-button-font-size',
                // Play Later Button
                '--play-later-button-bg',
                '--play-later-button-bg-hover', // Added
                '--play-later-button-fg',
                '--play-later-button-border-color',
                '--play-later-button-border-width',
                '--play-later-button-text-shadow',
                '--play-later-button-font-weight',
                '--play-later-button-border-radius',
                '--play-later-button-font-size',
                // Continue Button
                '--continue-button-bg',
                '--continue-button-bg-hover', // Added
                '--continue-button-fg',
                '--continue-button-border-color',
                '--continue-button-border-width',
                '--continue-button-text-shadow',
                '--continue-button-font-weight',
                '--continue-button-border-radius',
                '--continue-button-font-size'
            ]
        },
        {
            title: 'BUTTON BORDER RADIUS VARIABLES',
            variables: [
                '--accept-button-border-radius',
                '--play-now-button-border-radius',
                '--play-later-button-border-radius',
                '--continue-button-border-radius'
            ]
        },
        {
            title: 'BUTTON FONT SIZE VARIABLES',
            variables: [
                '--accept-button-font-size',
                '--play-now-button-font-size',
                '--play-later-button-font-size',
                '--continue-button-font-size'
            ]
        }
    ];

    let cssContent = ':root {\n';

    variableGroups.forEach(group => {
        cssContent += `    /* ${group.title} */\n`;
        group.variables.forEach(varName => {
            const value = getComputedStyle(document.documentElement).getPropertyValue(varName).trim();
            cssContent += `    ${varName}: ${value};\n`;
        });
        cssContent += '\n';
    });

    cssContent += '}';

    // Create a blob from the CSS content
    const blob = new Blob([cssContent], { type: 'text/css' });
    const url = URL.createObjectURL(blob);

    // Create a temporary link to trigger download
    const a = document.createElement('a');
    a.href = url;
    a.download = 'style.css';
    document.body.appendChild(a);
    a.click();

    // Clean up
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
}

function initExportFunction() {
    // Event Listener for Export Style Button
    document.getElementById('export-style-button').addEventListener('click', exportStyle);
}/* ============================================================
   FALLBACK BUTTON LISTENERS
   ============================================================ */

function setupFallbackButtonListeners() {
    acceptButton.addEventListener('click', () => {
        console.log('Accept button clicked');
        // Trigger the post-accept phase
        phaseToggle.checked = true;
        togglePhase();
    });

    playNowButton.addEventListener('click', () => {
        console.log('Play Now button clicked');
        // Add your Play Now button logic here
    });

    playLaterButton.addEventListener('click', () => {
        console.log('Play Later button clicked');
        // Add your Play Later button logic here
    });

    continueButton.addEventListener('click', () => {
        console.log('Continue button clicked');
        // Add your Continue button logic here
    });

}

/* ============================================================
   TEXT EFFECT BUTTON LISTENERS
   ============================================================ */

// Event Listeners for Action Buttons
document.getElementById('randomize-text-button').addEventListener('click', randomizeText);
document.getElementById('set-max-chars-button').addEventListener('click', setMaxChars);

/* ============================================================
   TEXT CONTROL FUNCTIONS
   ============================================================ */

/**
 * Generates lorem ipsum text up to a specified maximum number of characters.
 * Ensures that words are not cut off in the middle.
 * @param {number} maxChars - The maximum number of characters.
 * @returns {string} - The generated lorem ipsum text.
 */
function generateLoremIpsum(maxChars) {
    const lorem = "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.";
    if (lorem.length <= maxChars) {
        return lorem;
    }
    // Ensure we don't cut off in the middle of a word
    let truncated = lorem.substring(0, maxChars);
    const lastSpace = truncated.lastIndexOf(' ');
    if (lastSpace > 0) {
        truncated = truncated.substring(0, lastSpace);
    }
    return truncated;
}

/**
 * Randomizes the fallback text elements with random lorem ipsum text in Post-Accept Phase.
 * Only randomizes for the "prize" text since heading and description are typically user-defined.
 */
function randomizeText() {
    const isPostAccept = fallbackDiv.classList.contains('post-accept');

    if (!isPostAccept) {
        console.log('Randomize Text: Pre-Accept Phase - No Prize Text to Randomize.');
        return;
    }

    // Define maximum length for prize text
    const prizeMax = 250;

    // Generate random length for prize text
    const prizeLength = Math.floor(Math.random() * prizeMax) + 1; // 1 to 250

    // Generate random prize text
    const prizeText = generateLoremIpsum(prizeLength);

    // Set the prize text content
    prizeTextElement.textContent = prizeText;
}

/**
 * Sets the fallback text elements to their maximum character limits.
 * Only sets the prize text in Post-Accept Phase.
 */
function setMaxChars() {
    const isPostAccept = fallbackDiv.classList.contains('post-accept');

    if (!isPostAccept) {
        console.log('Set Max Chars: Pre-Accept Phase - No Prize Text to Set.');
        return;
    }

    // Define maximum character limit for prize text
    const prizeMax = 250;

    // Generate prize text with maximum characters
    const prizeText = generateLoremIpsum(prizeMax);

    // Set the prize text content
    prizeTextElement.textContent = prizeText;
}

/**
 * Updates the prize text based on the current phase.
 */
function updatePrizeText() {
    const isPostAccept = fallbackDiv.classList.contains('post-accept');
    if (isPostAccept) {
        prizeTextElement.textContent = "Exclusive rewards await: Join now!";
    } else {
        prizeTextElement.textContent = "";
    }
}
/**
 * Creates a text-shadow string if the toggle is on, else "none".
 */
function applyTextShadow(checked, offsetX, offsetY, blur, color) {
    if (checked) {
        return `${offsetX}px ${offsetY}px ${blur}px ${color}`;
    }
    return 'none';
}

function setupButtonStyling(config) {
    const {
        elementPrefix,
        varBg,
        varBgHover, // Added hover variable
        varFg,
        varBorderColor,
        varBorderWidth,
        varTextShadow,
        varFontWeight,
        varBorderRadius,
        varFontSize
    } = config;

    // HTML Inputs
    const bgPicker = document.getElementById(`${elementPrefix}-bg-color`);
    const bgHoverPicker = document.getElementById(`${elementPrefix}-bg-color-hover`); // Hover color picker
    const fgPicker = document.getElementById(`${elementPrefix}-fg-color`);
    const boldToggle = document.getElementById(`${elementPrefix}-bold-toggle`);
    const borderColorPicker = document.getElementById(`${elementPrefix}-border-color`);
    const borderWidthInput = document.getElementById(`${elementPrefix}-border-width`);
    const shadowToggle = document.getElementById(`${elementPrefix}-shadow-toggle`);
    const shadowOffsetX = document.getElementById(`${elementPrefix}-shadow-offset-x`);
    const shadowOffsetY = document.getElementById(`${elementPrefix}-shadow-offset-y`);
    const shadowBlur = document.getElementById(`${elementPrefix}-shadow-blur`);
    const shadowColor = document.getElementById(`${elementPrefix}-shadow-color`);
    const borderRadiusInput = document.getElementById(`${elementPrefix}-border-radius`);
    const fontSizeSlider = document.getElementById(`${elementPrefix}-font-size-slider`);
    const fontSizeValue = document.getElementById(`${elementPrefix}-font-size-value`);

    // Define unique localStorage keys
    const bgKey = `${elementPrefix}-bg-color-value`;
    const bgHoverKey = `${elementPrefix}-bg-color-hover-value`; // Hover key
    const fgKey = `${elementPrefix}-fg-color-value`;
    const boldKey = `${elementPrefix}-bold-toggle-value`;
    const borderColKey = `${elementPrefix}-border-color-value`;
    const borderWKey = `${elementPrefix}-border-width-value`;
    const shadowTKey = `${elementPrefix}-shadow-toggle-value`;
    const shadowOffXKey = `${elementPrefix}-shadow-offset-x-value`;
    const shadowOffYKey = `${elementPrefix}-shadow-offset-y-value`;
    const shadowBlurKey = `${elementPrefix}-shadow-blur-value`;
    const shadowColKey = `${elementPrefix}-shadow-color-value`;
    const borderRadKey = `${elementPrefix}-border-radius-value`;
    const fontSizeKey = `${elementPrefix}-font-size-slider-value`;

    function updateButtonStyles() {
        // Gather values
        const bgVal = bgPicker ? bgPicker.value : '#444444';
        const bgHoverVal = bgHoverPicker ? bgHoverPicker.value : '#666666'; // Hover value
        const fgVal = fgPicker ? fgPicker.value : '#ffffff';
        const isBold = boldToggle && boldToggle.checked;
        const bordColor = borderColorPicker ? borderColorPicker.value : '#ffffff';
        const bordWidth = borderWidthInput ? parseInt(borderWidthInput.value, 10) || 0 : 0;
        const isShadOn = shadowToggle && shadowToggle.checked;
        const offX = shadowOffsetX ? parseInt(shadowOffsetX.value, 10) || 0 : 0;
        const offY = shadowOffsetY ? parseInt(shadowOffsetY.value, 10) || 0 : 0;
        const shBlur = shadowBlur ? parseInt(shadowBlur.value, 10) || 0 : 0;
        const shColor = shadowColor ? shadowColor.value : '#000000';
        const radVal = borderRadiusInput ? parseInt(borderRadiusInput.value, 10) || 0 : 0;
        const fontSize = fontSizeSlider ? fontSizeSlider.value : 16; // Default font size

        // Apply to CSS
        document.documentElement.style.setProperty(varBg, bgVal);
        document.documentElement.style.setProperty(varBgHover, bgHoverVal); // Apply hover background
        document.documentElement.style.setProperty(varFg, fgVal);
        document.documentElement.style.setProperty(varFontWeight, isBold ? 'bold' : 'normal');
        document.documentElement.style.setProperty(varBorderColor, bordColor);
        document.documentElement.style.setProperty(varBorderWidth, `${bordWidth}px`);

        const shadowVal = applyTextShadow(isShadOn, offX, offY, shBlur, shColor);
        document.documentElement.style.setProperty(varTextShadow, shadowVal);

        document.documentElement.style.setProperty(varBorderRadius, `${radVal}px`);
        document.documentElement.style.setProperty(varFontSize, `${fontSize}px`); // Apply font size

        // Update displays
        if (fontSizeValue) {
            fontSizeValue.textContent = `${fontSize}px`;
        }

        // Save to localStorage
        if (bgPicker) updateSetting(bgKey, bgVal);
        if (bgHoverPicker) updateSetting(bgHoverKey, bgHoverVal); // Save hover value
        if (fgPicker) updateSetting(fgKey, fgVal);
        if (boldToggle) updateSetting(boldKey, isBold);
        if (borderColorPicker) updateSetting(borderColKey, bordColor);
        if (borderWidthInput) updateSetting(borderWKey, bordWidth);
        if (shadowToggle) updateSetting(shadowTKey, isShadOn);
        if (shadowOffsetX) updateSetting(shadowOffXKey, offX);
        if (shadowOffsetY) updateSetting(shadowOffYKey, offY);
        if (shadowBlur) updateSetting(shadowBlurKey, shBlur);
        if (shadowColor) updateSetting(shadowColKey, shColor);
        if (borderRadiusInput) updateSetting(borderRadKey, radVal);
        if (fontSizeSlider) updateSetting(fontSizeKey, fontSize);
    }

    // Attach event listeners
    if (bgPicker) bgPicker.addEventListener('input', updateButtonStyles);
    if (bgHoverPicker) bgHoverPicker.addEventListener('input', updateButtonStyles); // Hover picker listener
    if (fgPicker) fgPicker.addEventListener('input', updateButtonStyles);
    if (boldToggle) boldToggle.addEventListener('change', updateButtonStyles);
    if (borderColorPicker) borderColorPicker.addEventListener('input', updateButtonStyles);
    if (borderWidthInput) borderWidthInput.addEventListener('input', updateButtonStyles);
    if (shadowToggle) shadowToggle.addEventListener('change', updateButtonStyles);
    if (shadowOffsetX) shadowOffsetX.addEventListener('input', updateButtonStyles);
    if (shadowOffsetY) shadowOffsetY.addEventListener('input', updateButtonStyles);
    if (shadowBlur) shadowBlur.addEventListener('input', updateButtonStyles);
    if (shadowColor) shadowColor.addEventListener('input', updateButtonStyles);
    if (borderRadiusInput) borderRadiusInput.addEventListener('input', updateButtonStyles);
    if (fontSizeSlider) fontSizeSlider.addEventListener('input', updateButtonStyles);

    // On load, if we have saved settings, apply them to the DOM inputs
    if (settings[bgKey] && bgPicker) {
        bgPicker.value = settings[bgKey];
    }
    if (settings[bgHoverKey] && bgHoverPicker) { // Apply hover value on load
        bgHoverPicker.value = settings[bgHoverKey];
    }
    if (settings[fgKey] && fgPicker) {
        fgPicker.value = settings[fgKey];
    }
    if (settings[boldKey] !== undefined && boldToggle) {
        boldToggle.checked = settings[boldKey];
    }
    if (settings[borderColKey] && borderColorPicker) {
        borderColorPicker.value = settings[borderColKey];
    }
    if (settings[borderWKey] !== undefined && borderWidthInput) {
        borderWidthInput.value = settings[borderWKey];
    }
    if (settings[shadowTKey] !== undefined && shadowToggle) {
        shadowToggle.checked = settings[shadowTKey];
    }
    if (settings[shadowOffXKey] !== undefined && shadowOffsetX) {
        shadowOffsetX.value = settings[shadowOffXKey];
    }
    if (settings[shadowOffYKey] !== undefined && shadowOffsetY) {
        shadowOffsetY.value = settings[shadowOffYKey];
    }
    if (settings[shadowBlurKey] !== undefined && shadowBlur) {
        shadowBlur.value = settings[shadowBlurKey];
    }
    if (settings[shadowColKey] && shadowColor) {
        shadowColor.value = settings[shadowColKey];
    }
    if (settings[borderRadKey] !== undefined && borderRadiusInput) {
        borderRadiusInput.value = settings[borderRadKey];
    }
    if (settings[fontSizeKey] !== undefined && fontSizeSlider && fontSizeValue) {
        fontSizeSlider.value = settings[fontSizeKey];
        fontSizeValue.textContent = `${settings[fontSizeKey]}px`;
    }

    // Run once to ensure current settings are applied visually
    updateButtonStyles();
}

function initStylingButtons() {
    // Configuration for each button
    const buttonConfigs = [
        {
            elementPrefix: 'accept-button',
            varBg: '--accept-button-bg',
            varBgHover: '--accept-button-bg-hover', // Hover variable
            varFg: '--accept-button-fg',
            varBorderColor: '--accept-button-border-color',
            varBorderWidth: '--accept-button-border-width',
            varTextShadow: '--accept-button-text-shadow',
            varFontWeight: '--accept-button-font-weight',
            varBorderRadius: '--accept-button-border-radius',
            varFontSize: '--accept-button-font-size'
        },
        {
            elementPrefix: 'play-now-button',
            varBg: '--play-now-button-bg',
            varBgHover: '--play-now-button-bg-hover', // Hover variable
            varFg: '--play-now-button-fg',
            varBorderColor: '--play-now-button-border-color',
            varBorderWidth: '--play-now-button-border-width',
            varTextShadow: '--play-now-button-text-shadow',
            varFontWeight: '--play-now-button-font-weight',
            varBorderRadius: '--play-now-button-border-radius',
            varFontSize: '--play-now-button-font-size'
        },
        {
            elementPrefix: 'play-later-button',
            varBg: '--play-later-button-bg',
            varBgHover: '--play-later-button-bg-hover', // Hover variable
            varFg: '--play-later-button-fg',
            varBorderColor: '--play-later-button-border-color',
            varBorderWidth: '--play-later-button-border-width',
            varTextShadow: '--play-later-button-text-shadow',
            varFontWeight: '--play-later-button-font-weight',
            varBorderRadius: '--play-later-button-border-radius',
            varFontSize: '--play-later-button-font-size'
        },
        {
            elementPrefix: 'continue-button',
            varBg: '--continue-button-bg',
            varBgHover: '--continue-button-bg-hover', // Hover variable
            varFg: '--continue-button-fg',
            varBorderColor: '--continue-button-border-color',
            varBorderWidth: '--continue-button-border-width',
            varTextShadow: '--continue-button-text-shadow',
            varFontWeight: '--continue-button-font-weight',
            varBorderRadius: '--continue-button-border-radius',
            varFontSize: '--continue-button-font-size'
        }
    ];

    // Initialize button styling for each button
    buttonConfigs.forEach(cfg => {
        setupButtonStyling(cfg);
    });
}/**
 * Helper to update a text shadow CSS variable based on toggle + offset + blur + color.
 */
function applyTextShadowValue(checked, offsetXVal, offsetYVal, blurVal, colorVal) {
    if (checked) {
        return `${offsetXVal}px ${offsetYVal}px ${blurVal}px ${colorVal}`;
    }
    return 'none';
}

/**
 * Initializes and binds color picker and shadow controls for a specific text element.
 */
function setupTextStyling(config) {
    const {
        elementId,
        cssColorVar,
        cssShadowVar,
        cssFontWeightVar,
        cssWidthVar, 
        cssFontSizeVar
    } = config;

    // Color Picker
    const colorPicker = document.getElementById(`${elementId}-text-color`);
    const shadowToggle = document.getElementById(`${elementId}-drop-shadow-toggle`);
    const shadowOffsetX = document.getElementById(`${elementId}-shadow-offset-x`);
    const shadowOffsetY = document.getElementById(`${elementId}-shadow-offset-y`);
    const shadowBlur = document.getElementById(`${elementId}-shadow-blur`);
    const shadowColor = document.getElementById(`${elementId}-shadow-color`);
    const boldToggle = document.getElementById(`${elementId}-bold-toggle`);
    const widthSlider = document.getElementById(`${elementId}-width-slider`);
    const widthValue = document.getElementById(`${elementId}-width-value`);
    const fontSizeSlider = document.getElementById(`${elementId}-font-size-slider`);
    const fontSizeValue = document.getElementById(`${elementId}-font-size-value`);

    // Define unique keys for local storage
    const colorKey = `${elementId}-text-color-value`;
    const shadowKey = `${elementId}-drop-shadow-toggle`;
    const offsetXKey = `${elementId}-shadow-offset-x-value`;
    const offsetYKey = `${elementId}-shadow-offset-y-value`;
    const blurKey = `${elementId}-shadow-blur-value`;
    const shadowColKey = `${elementId}-shadow-color-value`;
    const boldKey = `${elementId}-bold-toggle-value`;
    const widthKey = `${elementId}-width-slider-value`;
    const fontSizeKey = `${elementId}-font-size-slider-value`;

    function updateTextStyles() {
        // Gather current values
        const color = colorPicker ? colorPicker.value : '#ffffff';
        const isShadowEnabled = shadowToggle && shadowToggle.checked;
        const offX = shadowOffsetX ? parseInt(shadowOffsetX.value, 10) || 0 : 0;
        const offY = shadowOffsetY ? parseInt(shadowOffsetY.value, 10) || 0 : 0;
        const blr = shadowBlur ? parseInt(shadowBlur.value, 10) || 0 : 0;
        const shColor = shadowColor ? shadowColor.value : '#000000';
        const isBold = boldToggle && boldToggle.checked;
        const width = widthSlider ? widthSlider.value : 80; // Default width
        const fontSize = fontSizeSlider ? fontSizeSlider.value : 24; // Default font size

        // Apply to CSS
        document.documentElement.style.setProperty(cssColorVar, color);
        const shadowVal = applyTextShadowValue(isShadowEnabled, offX, offY, blr, shColor);
        document.documentElement.style.setProperty(cssShadowVar, shadowVal);
        document.documentElement.style.setProperty(cssFontWeightVar, isBold ? 'bold' : 'normal');
        document.documentElement.style.setProperty(cssWidthVar, `${width}%`); // Apply width
        document.documentElement.style.setProperty(cssFontSizeVar, `${fontSize}px`); // Apply font size

        // Update displays
        if (widthValue) {
            widthValue.textContent = `${width}%`;
        }
        if (fontSizeValue) {
            fontSizeValue.textContent = `${fontSize}px`;
        }

        // Save to localStorage
        if (colorPicker) updateSetting(colorKey, color);
        if (shadowToggle) updateSetting(shadowKey, isShadowEnabled);
        if (shadowOffsetX) updateSetting(offsetXKey, offX);
        if (shadowOffsetY) updateSetting(offsetYKey, offY);
        if (shadowBlur) updateSetting(blurKey, blr);
        if (shadowColor) updateSetting(shadowColKey, shColor);
        if (boldToggle) updateSetting(boldKey, isBold);
        if (widthSlider) updateSetting(widthKey, width);
        if (fontSizeSlider) updateSetting(fontSizeKey, fontSize);
    }

    // Attach event listeners
    if (colorPicker) {
        colorPicker.addEventListener('input', updateTextStyles);
    }
    if (shadowToggle) shadowToggle.addEventListener('change', updateTextStyles);
    if (shadowOffsetX) shadowOffsetX.addEventListener('input', updateTextStyles);
    if (shadowOffsetY) shadowOffsetY.addEventListener('input', updateTextStyles);
    if (shadowBlur) shadowBlur.addEventListener('input', updateTextStyles);
    if (shadowColor) shadowColor.addEventListener('input', updateTextStyles);
    if (boldToggle) boldToggle.addEventListener('change', updateTextStyles);
    if (widthSlider) widthSlider.addEventListener('input', updateTextStyles); // Existing
    if (fontSizeSlider) fontSizeSlider.addEventListener('input', updateTextStyles);

    // On load, if we have saved settings, apply them to the DOM elements
    if (settings[colorKey] && colorPicker) {
        colorPicker.value = settings[colorKey];
    }
    if (settings[shadowKey] !== undefined && shadowToggle) {
        shadowToggle.checked = settings[shadowKey];
    }
    if (settings[offsetXKey] !== undefined && shadowOffsetX) {
        shadowOffsetX.value = settings[offsetXKey];
    }
    if (settings[offsetYKey] !== undefined && shadowOffsetY) {
        shadowOffsetY.value = settings[offsetYKey];
    }
    if (settings[blurKey] !== undefined && shadowBlur) {
        shadowBlur.value = settings[blurKey];
    }
    if (settings[shadowColKey] && shadowColor) {
        shadowColor.value = settings[shadowColKey];
    }
    if (settings[boldKey] !== undefined && boldToggle) {
        boldToggle.checked = settings[boldKey];
    }
    if (settings[widthKey] !== undefined && widthSlider && widthValue) {
        widthSlider.value = settings[widthKey];
        widthValue.textContent = `${settings[widthKey]}%`;
    }
    if (settings[fontSizeKey] !== undefined && fontSizeSlider && fontSizeValue) {
        fontSizeSlider.value = settings[fontSizeKey];
        fontSizeValue.textContent = `${settings[fontSizeKey]}px`;
    }

    // Run once to ensure current settings are applied visually
    updateTextStyles();
}

function initStylingText() {
    // Updated text elements configuration to include font-size variables
    const textElements = [
        // Pre-accept heading
        {
            elementId: 'heading',
            cssColorVar: '--fallback-heading-color',
            cssShadowVar: '--fallback-heading-text-shadow',
            cssFontWeightVar: '--fallback-heading-font-weight',
            cssWidthVar: '--fallback-heading-width',
            cssFontSizeVar: '--fallback-heading-font-size'
        },
        // Pre-accept description
        {
            elementId: 'description',
            cssColorVar: '--fallback-description-color',
            cssShadowVar: '--fallback-description-text-shadow',
            cssFontWeightVar: '--fallback-description-font-weight',
            cssWidthVar: '--fallback-description-width',
            cssFontSizeVar: '--fallback-description-font-size'
        },
        // Post-accept heading
        {
            elementId: 'post-accept-heading',
            cssColorVar: '--post-accept-fallback-heading-color',
            cssShadowVar: '--post-accept-fallback-heading-text-shadow',
            cssFontWeightVar: '--post-accept-fallback-heading-font-weight',
            cssWidthVar: '--post-accept-fallback-heading-width',
            cssFontSizeVar: '--post-accept-fallback-heading-font-size'
        },
        // Post-accept description
        {
            elementId: 'post-accept-description',
            cssColorVar: '--post-accept-fallback-description-color',
            cssShadowVar: '--post-accept-fallback-description-text-shadow',
            cssFontWeightVar: '--post-accept-fallback-description-font-weight',
            cssWidthVar: '--post-accept-fallback-description-width',
            cssFontSizeVar: '--post-accept-fallback-description-font-size'
        },
        // Post-accept prize
        {
            elementId: 'post-accept-prize',
            cssColorVar: '--post-accept-fallback-prize-color',
            cssShadowVar: '--post-accept-fallback-prize-text-shadow',
            cssFontWeightVar: '--post-accept-fallback-prize-font-weight',
            cssWidthVar: '--post-accept-fallback-prize-width',
            cssFontSizeVar: '--post-accept-fallback-prize-font-size'
        }
    ];

    // Initialize text styling for each element
    textElements.forEach((config) => {
        setupTextStyling(config);
    });
}/**
 * Toggles the maximized state of the preview panel.
 */
function toggleMaximize() {
    const isMaximized = previewPanel.classList.contains('preview-maximized');

    if (isMaximized) {
        // Exit Maximized View
        previewPanel.classList.remove('preview-maximized');
        closeMaximizeButton.style.display = 'none';
    } else {
        // Enter Maximized View
        previewPanel.classList.add('preview-maximized');
        closeMaximizeButton.style.display = 'block';
    }

    // Adjust overlay size after transition
    setTimeout(adjustOverlaySize, 300);
}

function initMaximizeFunction() {
    window.previewPanel = document.querySelector('.fallback');
    window.closeMaximizeButton = document.getElementById('close-maximize-button');

    // Event Listener for Keyboard Shortcut (Ctrl+F or Cmd+F)
    document.addEventListener('keydown', (event) => {
        const isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        const modifier = isMac ? event.metaKey : event.ctrlKey;
        const key = event.key.toLowerCase();

        // Check for Ctrl+F or Cmd+F
        if (modifier && key === 'f') {
            event.preventDefault(); // Prevent the default browser Find action
            toggleMaximize();
        }
    });

    // Event Listener for Close Maximize Button
    closeMaximizeButton.addEventListener('click', toggleMaximize);


}

/**
 * Loads settings from localStorage, if any exist.
 */
function loadSettings() {
    const stored = localStorage.getItem(localStorageKey);
    if (!stored) {
        return; // No saved settings, do nothing
    }
    try {
        const parsed = JSON.parse(stored);
        if (parsed && typeof parsed === 'object') {
            settings = parsed;
        }
    } catch (err) {
        console.warn('Could not parse stored settings:', err);
    }
}

/**
 * Saves the current settings object to localStorage.
 */
function saveSettings() {
    localStorage.setItem(localStorageKey, JSON.stringify(settings));
}

/**
 * Updates a specific setting key with the given value, then saves.
 */
function updateSetting(key, value) {
    settings[key] = value;
    saveSettings();
}

/* ============================================================
   ELEMENT HANDLE SETUP
   ============================================================ */
function setupElementHandles() {
    window.phaseToggle = document.getElementById('phase-toggle');
    window.useContinueToggle = document.getElementById('use-continue-toggle');
    window.fallbackDiv = document.getElementById('fallback-div');
    window.toolPanelOptions = document.querySelector('.tool-panel-options');

    window.fallbackButtons = document.getElementById('fallback-buttons');
    window.acceptButton = document.getElementById('fallback-button-accept');
    window.playNowButton = document.getElementById('fallback-button-play-now');
    window.playLaterButton = document.getElementById('fallback-button-play-later');
    window.continueButton = document.getElementById('fallback-button-continue');

    window.prizeTextElement = document.getElementById('fallback-prize');
}


/* ============================================================
   FALLBACK OVERLAY RESIZING
   ============================================================ */
function adjustOverlaySize() {
    const img = document.getElementById('fallback-image');
    const overlay = document.getElementById('fallback-overlay');
    if (img && overlay) {
        const imgWidth = img.clientWidth;
        const imgHeight = img.clientHeight;
        overlay.style.width = imgWidth + 'px';
        overlay.style.height = imgHeight + 'px';
        overlay.style.top = img.offsetTop + 'px';
        overlay.style.left = img.offsetLeft + 'px';
    }
}

function initDynamicFallbackSized() {
    // Handle image load
    const imgElement = document.getElementById('fallback-image');
    if (imgElement.complete) {
        // If image is already loaded (from cache)
        adjustOverlaySize();
    } else {
        imgElement.addEventListener('load', adjustOverlaySize);
    }

    // Window resize event
    window.addEventListener('resize', adjustOverlaySize);

    // ResizeObserver for dynamic image resizing
    if ('ResizeObserver' in window) {
        const resizeObserver = new ResizeObserver(() => {
            adjustOverlaySize();
        });
        resizeObserver.observe(imgElement);
    } else {
        console.warn('ResizeObserver is not supported by this browser.');
    }
}

/* ============================================================
   FALLBACK PHASE AND TYPE TOGGLE
   ============================================================ */

function setupPhaseTypeToggle() {
    phaseToggle.addEventListener('change', togglePhase);
    useContinueToggle.addEventListener('change', toggleUseContinue);

    // 1) Phase Toggle
    if (typeof settings.phaseToggle === 'boolean') {
        phaseToggle.checked = settings.phaseToggle;
    }
    // 2) Use Continue
    if (typeof settings.useContinue === 'boolean') {
        useContinueToggle.checked = settings.useContinue;
    }
}

/**
 * Toggles between Pre-Accept and Post-Accept phases, saves to localStorage.
 */
function togglePhase() {
    const isPostAccept = phaseToggle.checked;
    updateSetting('phaseToggle', isPostAccept);

    // Remove both classes first to reset
    fallbackDiv.classList.remove('pre-accept');
    fallbackDiv.classList.remove('post-accept');

    if (isPostAccept) {
        fallbackDiv.classList.add('post-accept');
        toolPanelOptions.classList.add('post-accept');
    } else {
        fallbackDiv.classList.add('pre-accept');
        toolPanelOptions.classList.remove('post-accept');
    }
    updateButtonVisibility();
    updateImageSource();
    updatePrizeText(); // Update prize text visibility
}

/**
 * Toggles the Use Continue functionality, saves to localStorage.
 */
function toggleUseContinue() {
    const useContinue = useContinueToggle.checked;
    updateSetting('useContinue', useContinue);
    updateButtonVisibility();
}

/**
 * Updates the visibility of buttons based on the current phase and useContinue toggle.
 */
function updateButtonVisibility() {
    const isPostAccept = fallbackDiv.classList.contains('post-accept');
    const useContinue = useContinueToggle.checked;

    if (useContinue && isPostAccept) {
        // Show Continue button only in Post-Accept Phase
        continueButton.style.display = 'block';
        // Hide Play Now and Play Later buttons
        playNowButton.style.display = 'none';
        playLaterButton.style.display = 'none';
        // Hide Accept button in Post-Accept phase
        acceptButton.style.display = 'none';
    } else {
        // Hide Continue button
        continueButton.style.display = 'none';

        if (isPostAccept) {
            // Hide Accept button in Post-Accept phase
            acceptButton.style.display = 'none';
            // Show Play Now and Play Later buttons
            playNowButton.style.display = 'block';
            playLaterButton.style.display = 'block';
        } else {
            // Show Accept button in Pre-Accept phase
            acceptButton.style.display = 'block';
            // Hide Play Now and Play Later buttons
            playNowButton.style.display = 'none';
            playLaterButton.style.display = 'none';
        }
    }
}

/**
 * Updates the image source based on the current phase.
 */
function updateImageSource() {
    const imgElement = document.getElementById('fallback-image');
    if (!imgElement) {
        console.warn('Fallback image element not found.');
        return;
    }

    const isPostAccept = fallbackDiv.classList.contains('post-accept');
    if (isPostAccept) {
        imgElement.src = 'dev/outro.png';
        imgElement.alt = 'Outro Image';
        console.log('Switched to Post-Accept Phase Image: dev/outro.png');
    } else {
        imgElement.src = 'dev/intro.png';
        imgElement.alt = 'Intro Image';
        console.log('Switched to Pre-Accept Phase Image: dev/intro.png');
    }
}



function setupConfigs() {
    // Updated slider configurations including width and font-size sliders
    window.sliderConfigs = [
        // Initial Phase Position Sliders
        { sliderId: 'heading-position-slider', valueId: 'heading-position-value', cssVariable: '--fallback-heading-top' },
        { sliderId: 'description-position-slider', valueId: 'description-position-value', cssVariable: '--fallback-description-top' },
        
        // Initial Phase Width Sliders
        { sliderId: 'heading-width-slider', valueId: 'heading-width-value', cssVariable: '--fallback-heading-width' },
        { sliderId: 'description-width-slider', valueId: 'description-width-value', cssVariable: '--fallback-description-width' },

        // Initial Phase Font Size Sliders
        { sliderId: 'heading-font-size-slider', valueId: 'heading-font-size-value', cssVariable: '--fallback-heading-font-size' },
        { sliderId: 'description-font-size-slider', valueId: 'description-font-size-value', cssVariable: '--fallback-description-font-size' },

        // Accept Button Position Slider
        { sliderId: 'accept-button-vertical-slider', valueId: 'accept-button-vertical-value', cssVariable: '--fallback-button-accept-top' },

        // Accept Button Font Size Slider
        { sliderId: 'accept-button-font-size-slider', valueId: 'accept-button-font-size-value', cssVariable: '--accept-button-font-size' }, // New CSS Variable

        // Post-Accept Phase Position Sliders
        { sliderId: 'post-accept-heading-position-slider', valueId: 'post-accept-heading-position-value', cssVariable: '--post-accept-fallback-heading-top' },
        { sliderId: 'post-accept-description-position-slider', valueId: 'post-accept-description-position-value', cssVariable: '--post-accept-fallback-description-top' },
        { sliderId: 'post-accept-prize-position-slider', valueId: 'post-accept-prize-position-value', cssVariable: '--post-accept-fallback-prize-top' },
        { sliderId: 'post-accept-play-now-button-vertical-slider', valueId: 'post-accept-play-now-button-vertical-value', cssVariable: '--post-accept-fallback-button-play-now-top' },
        { sliderId: 'post-accept-play-later-button-vertical-slider', valueId: 'post-accept-play-later-button-vertical-value', cssVariable: '--post-accept-fallback-button-play-later-top' },
        { sliderId: 'post-accept-continue-button-vertical-slider', valueId: 'post-accept-continue-button-vertical-value', cssVariable: '--post-accept-fallback-button-continue-top' },

        // Post-Accept Phase Width Sliders
        { sliderId: 'post-accept-heading-width-slider', valueId: 'post-accept-heading-width-value', cssVariable: '--post-accept-fallback-heading-width' },
        { sliderId: 'post-accept-description-width-slider', valueId: 'post-accept-description-width-value', cssVariable: '--post-accept-fallback-description-width' },
        { sliderId: 'post-accept-prize-width-slider', valueId: 'post-accept-prize-width-value', cssVariable: '--post-accept-fallback-prize-width' },

        // Post-Accept Phase Font Size Sliders
        { sliderId: 'post-accept-heading-font-size-slider', valueId: 'post-accept-heading-font-size-value', cssVariable: '--post-accept-fallback-heading-font-size' },
        { sliderId: 'post-accept-description-font-size-slider', valueId: 'post-accept-description-font-size-value', cssVariable: '--post-accept-fallback-description-font-size' },
        { sliderId: 'post-accept-prize-font-size-slider', valueId: 'post-accept-prize-font-size-value', cssVariable: '--post-accept-fallback-prize-font-size' },

        // Button Font Size Sliders
        { sliderId: 'play-now-button-font-size-slider', valueId: 'play-now-button-font-size-value', cssVariable: '--play-now-button-font-size' }, // New
        { sliderId: 'play-later-button-font-size-slider', valueId: 'play-later-button-font-size-value', cssVariable: '--play-later-button-font-size' }, // New
        { sliderId: 'continue-button-font-size-slider', valueId: 'continue-button-font-size-value', cssVariable: '--continue-button-font-size' } // New
    ];
}/* ============================================================
   SLIDER SETUP
   ============================================================ */

/**
 * Initializes and binds slider events to update CSS variables and save to localStorage.
 * @param {string} sliderId - The ID of the slider input element.
 * @param {string} valueId - The ID of the span element displaying the slider value.
 * @param {string} cssVariable - The CSS variable to update.
 */
function setupSlider(sliderId, valueId, cssVariable) {
    const slider = document.getElementById(sliderId);
    const valueDisplay = document.getElementById(valueId);

    if (!slider || !valueDisplay) {
        console.warn(`Slider or value display not found for ID: ${sliderId}`);
        return;
    }

    function updateValue() {
        const value = slider.value;
        if (cssVariable.includes('font-size')) {
            valueDisplay.textContent = `${value}px`;
            document.documentElement.style.setProperty(cssVariable, `${value}px`);
        } else {
            valueDisplay.textContent = `${value}%`;
            document.documentElement.style.setProperty(cssVariable, `${value}%`);
        }

        // Save to localStorage
        const savedKey = `${sliderId}-value`;
        updateSetting(savedKey, value);
    }

    // Listen for slider changes
    slider.addEventListener('input', updateValue);

    // Return the function so we can call it during applySettings()
    return { slider, updateValue };
}

function createSliders() {
    // Existing slider setups
    const sliderSetups = [];



    sliderConfigs.forEach(cfg => {
        const { sliderId, valueId, cssVariable } = cfg;
        const result = setupSlider(sliderId, valueId, cssVariable);
        // If setupSlider found the elements and returned references, store them
        if (result) {
            sliderSetups.push(result);
        }
    });

    // Now that each slider is set up, let's see if we have stored values for them
    sliderConfigs.forEach(({ sliderId, valueId, cssVariable }) => {
        const savedKey = `${sliderId}-value`;
        const slider = document.getElementById(sliderId);
        const valueDisplay = document.getElementById(valueId);

        if (slider && settings[savedKey] !== undefined) {
            slider.value = settings[savedKey];
            // Call the same logic as "updateValue()"
            if (cssVariable.includes('font-size')) {
                valueDisplay.textContent = `${slider.value}px`;
                document.documentElement.style.setProperty(cssVariable, `${slider.value}px`);
            } else {
                valueDisplay.textContent = `${slider.value}%`;
                document.documentElement.style.setProperty(cssVariable, `${slider.value}%`);
            }
        }
    });

}

function triggerTabNav(btn) {
    btn.addEventListener('click', () => {
        // Remove active class from all buttons
        tabBtns.forEach((tabBtn) => {
            tabBtn.classList.remove('active');
            tabBtn.classList.add('inactive');
        });

        // Add active class to clicked button
        btn.classList.remove('inactive');
        btn.classList.add('active');

        // Hide all tab contents
        tabContents.forEach((tabContent) => {
            tabContent.style.display = 'none';
        });

        // Show the corresponding tab content
        let tabContent = document.getElementById(btn.dataset.tab);
        tabContent.style.display = 'block';
    });
}

function applyTabSettings() {
    // Get active element
    let activeElement = document.querySelector('.tab-btn.active');

    // Hide all tab contents
    tabContents.forEach((tabContent) => {
        tabContent.style.display = 'none';
    });

    // Show the corresponding tab content
    let tabContent = document.getElementById(activeElement.dataset.tab);
    tabContent.style.display = 'block';
}

function initTabNavigation() {
    // Tab Navigation
    window.tabBtns = document.querySelectorAll('.tab-btn');
    window.tabContents = document.querySelectorAll('.options-tab');

    tabBtns.forEach((btn) => {
        triggerTabNav(btn);
    });
}// .\static\tool\fallbackcreator\ui.js

/* ============================================================
   GLOBAL STATE & LOCAL STORAGE HANDLING
   ============================================================ */
const localStorageKey = 'fallbackCreatorSettings';

// We'll store user settings in this object:
let settings = {};


console.log('Fallback Creator UI loaded');
loadSettings(); 
setupElementHandles()
setupConfigs();
setupPhaseTypeToggle();
setupFallbackButtonListeners();

initDynamicFallbackSized();
initMaximizeFunction();
createSliders();

initStylingText();
initStylingButtons();

initExportFunction();

initTabNavigation();
applyTabSettings();

// Re-apply phase toggles
togglePhase();
toggleUseContinue();
updatePrizeText();
